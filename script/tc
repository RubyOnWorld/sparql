#!/usr/bin/env ruby
require 'rubygems'
require "bundler/setup"
require 'linkeddata'
require 'rspec'
require_relative '../lib/sparql'
require 'sxp'
require 'sparql/extensions'
require 'sparql/algebra/extensions'
require_relative "../spec/spec_helper"
require_relative "../spec/dawg_helper"
require_relative "../spec/support/extensions/comparitors"
require_relative "../spec/support/extensions/isomorphic"
require 'getoptlong'

# Extend RDF::Enumerables with these functions.
class RDF::Repository 
  include RDF::Isomorphic
end

ASSERTOR = "https://greggkellogg.net/foaf#me"
RUN_TIME = Time.now

def earl_preamble(options)
  options[:output].write File.read(File.expand_path("../../etc/doap.ttl", __FILE__))
  options[:output].puts %(
<https://rubygems.org/gems/sparql> doap:release [
  doap:name "sparql-#{SPARQL::VERSION}";
  doap:revision "#{SPARQL::VERSION}";
  doap:created "#{File.mtime(File.expand_path('../../VERSION', __FILE__)).strftime('%Y-%m-%d')}"^^xsd:date;
] .
<> foaf:primaryTopic <https://rubygems> ;
  dc:issued "#{RUN_TIME.xmlschema}"^^xsd:dateTime ;
  foaf:maker <#{ASSERTOR}> .

<#{ASSERTOR}> a earl:Assertor;
  foaf:title "Implementor" .
)
end

def run_tc(tc, **options)
  options[:msg] ||= {}
  options[:tests] ||= 0
  options[:tests] += 1
  stderr, $stderr = $stderr, StringIO.new unless options[:debug]

  id = tc.attributes['id'].
    sub(SPARQL::Spec::BASE_URI_10, '').
    sub(SPARQL::Spec::BASE_URI_11, '')
  STDERR.write "run #{id}" unless options[:quiet]

  result = "untested"

  if options[:verbose]
    STDERR.puts "\nTestCase: #{tc.inspect}"
    STDERR.puts "\nInput:\n" + tc.query_string if tc.query_string
    STDERR.puts "\nData:\n" + tc.data_string if tc.respond_to?(:data) && tc.data
    STDERR.puts "\nTest Data:\n" + tc.test_data_string if tc.respond_to?(:test_data_string) && tc.test_data_string
    STDERR.puts "\nExpected:\n" + tc.solutions.to_sse if tc.respond_to?(:solutions)
  end

  case tc.name
  when 'Basic - Term 6', 'Basic - Term 7', 'syntax-lit-08.rq'
     # Decimal format changed in SPARQL 1.1
  when 'syntax-esc-04.rq', 'syntax-esc-05.rq'
    # PNAME_LN changed in SPARQL 1.1
  when 'datatype-2 : Literals with a datatype'
     # datatype now returns rdf:langString for language-tagged literals
  when /REDUCED/
     # REDUCED equivalent to DISTINCT
  when /pp11|pp31/
     # Expects multiple equivalent property path solutions
  else
    case tc.type
    when 'mf:QueryEvaluationTest'
      actual = sparql_query(graphs: tc.graphs, query: tc.action.query_string,
                            base_uri: RDF::URI(tc.action.query_file),
                            form: tc.form, to_hash: false)

      STDERR.puts "Actual: #{actual.to_sse}" if options[:verbose]

      case tc.form
      when :select, :create, :describe, :construct
        if actual.isomorphic_with?(tc.solutions)
          result = "passed"
        else
          if options[:verbose]
            STDERR.puts "Missing:\n#{(tc.solutions - actual).to_sse}" unless (tc.solutions - actual).empty?
            STDERR.puts "Extra:\n#{(tc.solutions - actual).to_sse}" unless (actual - tc.solutions).empty?
          end
          result = "failed"
        end
      when :ask
        if actual == tc.solutions
          result = "passed"
        else
          result = "failed"
        end
      else
        STDERR.puts "unknown form #{tc.form.inspect}"
      end
    when 'mf:CSVResultFormatTest'
      actual = sparql_query(graphs: tc.graphs,
                            query: tc.action.query_string,
                            base_uri: RDF::URI(tc.action.query_file),
                            form: tc.form)

      STDERR.puts "Actual: #{actual.to_sse}" if options[:verbose]

      simplified_solutions = RDF::Query::Solutions.new
      actual.each do |solution|
        solution = solution.dup
        actual.variable_names.each do |name|
          value = solution[name] ||= RDF::Literal("")
          solution[name] = RDF::Literal(value.to_s) if value.literal? && !value.simple?
        end
        simplified_solutions << solution
      end

      if simplified_solutions.isomorphic_with?(tc.solutions)
        result = "passed"
      else
        if options[:verbose]
          STDERR.puts "Missing:\n#{(tc.solutions - actual).to_sse}" unless (tc.solutions - actual).empty?
          STDERR.puts "Extra:\n#{(tc.solutions - actual).to_sse}" unless (actual - tc.solutions).empty?
        end
        result = "failed"
      end
    when 'ut:UpdateEvaluationTest', 'mf:UpdateEvaluationTest'
      # Load default and named graphs for result dataset
      expected = RDF::Repository.new do |r|
        tc.result.graphs.each do |info|
          data, format = info[:data], info[:format]
          if data
            RDF::Reader.for(format).new(data, info).each_statement do |st|
              st.graph_name = RDF::URI(info[:base_uri]) if info[:base_uri]
              r << st
            end
          end
        end
      end

      actual = sparql_query(graphs: tc.action.graphs,
                            query: tc.action.query_string,
                            base_uri: RDF::URI(tc.action.query_file),
                            form: tc.form,
                            debug: options[:debug])

      STDERR.puts "Actual: #{actual.dump(:trig)}" if options[:verbose]
      if actual.isomorphic_with?(expected)
        result = "passed"
      else
        result = "failed"
      end
    when 'mf:PositiveSyntaxTest', 'mf:PositiveSyntaxTest11'
      SPARQL.parse(tc.action.query_string, base_uri: tc.base_uri, validate: true)
      # No exception means it passes
      result = "passed"
    when 'mf:NegativeSyntaxTest', 'mf:NegativeSyntaxTest11'
      begin
        SPARQL.parse(tc.action.query_string, base_uri: tc.base_uri, validate: true)
      rescue Exception => e
        result = "passed"
      end
      unless result == "passed"
        result = "failed"
      end
    when 'mf:PositiveUpdateSyntaxTest11'
      SPARQL.parse(tc.action.query_string, base_uri: tc.base_uri, update: true, validate: true)
      # No exception means it passes
      result = "passed"
    when 'mf:NegativeUpdateSyntaxTest11'
      begin
        SPARQL.parse(tc.action.query_string, base_uri: tc.base_uri, update: true, validate: true)
      rescue Exception => e
        result = "passed"
      end
      unless result == "passed"
        result = "failed"
      end
    else
      STDERR.puts "unknown test type #{tc.type}"
    end
  end
  options[:results][result] ||= 0
  options[:results][result] += 1
rescue Interrupt
  exit(1)
rescue Exception => e
  if options[:quiet]
    options[:results]['exception'] ||= 0
    options[:results]['exception'] += 1
  else
    STDERR.puts("Exception: #{e.message}")
    if options[:verbose]
      STDERR.puts e.backtrace
      STDERR.puts $stderr.read
    end
  end
  $stderr = stderr unless options[:debug]
  result = 'failed'
ensure

  if options[:earl]
    options[:output].puts %{
[ a earl:Assertion;
  earl:assertedBy <#{ASSERTOR}>;
  earl:subject <https://rubygems.org/gems/sparql>;
  earl:test <#{tc.attributes['id']}>;
  earl:result [
    a earl:TestResult;
    earl:outcome earl:#{result};
    dc:name """#{tc.name}""";
    dc:date "#{RUN_TIME.xmlschema}"^^xsd:dateTime];
  earl:mode earl:automatic ] .
}
  end

  if options[:quiet]
    STDERR.write(result == 'passed' ? '.' : result[0,1])
  else
    puts result
  end
end

options = {
  output:   STDOUT,
  quite:    false,
  results: {},
  validate: false,
  verbose:  false,
}
opts = GetoptLong.new(
  ["--earl", GetoptLong::NO_ARGUMENT],
  ["--debug", GetoptLong::NO_ARGUMENT],
  ["--output", "-o", GetoptLong::REQUIRED_ARGUMENT],
  ["--quiet", GetoptLong::NO_ARGUMENT],
  ["--verbose", GetoptLong::NO_ARGUMENT],
)
opts.each do |opt, arg|
  case opt
  when '--earl'         then options[:quiet] = options[:earl] = true
  when '--debug'        then options[:debug] = true
  when '--output'       then options[:output] = File.open(arg, "w")
  when '--quiet'        then options[:quiet] = true
  when '--validate'     then options[:validate] = true
  when '--verbose'      then options[:verbose] = true; ENV['EXEC_DEBUG'] = "2"
  end
end

earl_preamble(options) if options[:earl]

[SPARQL::Spec.sparql1_0_syntax_tests, SPARQL::Spec.sparql1_0_tests, SPARQL::Spec.sparql1_1_tests].each do |suite|
  main_man = SPARQL::Spec::Manifest.open(suite)
  main_man.include.reject do |m|
    %w{
      entailment
      
      csv-tsv-res
      http-rdf-dupdate
      protocol
      service-description
      service
      syntax-fed
    }.include?(m.attributes['id'].to_s.split('/')[-2])
  end.each do |man|
    puts ["Suite", man.attributes['rdfs:label'], man.attributes['rdfs:comment'], man.comment].compact.join(" - ") if options[:verbose] && ARGV.empty?
    man.entries.each do |tc|
      next unless tc.action
      name = Array(tc.name).join("") + Array(tc.entry).join("")
      next unless ARGV.empty? || ARGV.any? do |n|
        tc.attributes['id'].match?(/#{n}/) ||
        tc.action.is_a?(Hash) && tc.action['mq:query'].match?(/n/) ||
        name.match(/#{n}/)
      end
      run_tc(tc, **options)
    end
  end
end

STDERR.puts "" if options[:quiet]
options[:results].each {|k, v| puts "#{k}: #{v}"}
